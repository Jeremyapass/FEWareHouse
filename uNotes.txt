CATATAN :
1. JS adalah logika dan bahasa vanilla JS
    + Di JS tidak bisa support <div><div/> tanpa adanya sesuatu a
2. JSX adalah logika dan bahasa yang mencampurkan html dan JS 
    + Contoh :
        - di JSX kita bisa buat <div><div/> dan diterima/disupport lebih baik

KESIMPULAN : 
-di TSX tidak bisa memakai logika JS, karena TS dan JS itu berbeda, walaupun TS adalah lanjutan dari JS. begitu juga sebaliknya
-Tetapi di JS dapat memakai TS, dan di TS dapat memakai JS.

3. Contoh penggunaan {children}

import React from 'react';

// Komponen MainLayout dengan children
const MainLayout = ({ children }) => {
  return (
    <div className="main-layout">
      {children}
    </div>
  );
};

// Contoh penggunaan komponen MainLayout
const App = () => {
  return (
    <MainLayout>
      <header>
        <h1>Welcome to my website</h1>
      </header>
      <nav>
        <ul>
          <li>Home</li>
          <li>About</li>
          <li>Contact</li>
        </ul>
      </nav>
      <main>
        <p>This is the main content of the website.</p>
      </main>
      <footer>
        <p>&copy; 2024 My Website</p>
      </footer>
    </MainLayout>
  );
};

export default App;

Di sini, MainLayout adalah komponen yang menerima properti children. Ketika App menggunakan MainLayout, seluruh isi di dalam tag <MainLayout> akan dianggap sebagai children dari MainLayout. Dalam contoh ini, kita menyertakan elemen <header>, <nav>, <main>, dan <footer> sebagai children dari MainLayout.

4. Penamaan di dalam file di dalam folder itu penting : 

    - tetap bisa masuk kode nya tanpa dipasangin <RootLayOut> karena dia berapa di folder app. Yang di mana otomatis /
    dan penamaan tampilan yang diambil adalah page.jsx

    Misal : 
    /app
    -pages.jsx
    -page.jsx

    maka yang diambil adalah yang page.jsx
    nama file apapun selain page, maka tidak akan diambil menjadi tampilan nextjs

    - Contoh seperti di /(main)
    layout.jsx itu adalah penamaan untuk pembungkus si pages" dari folder" tersebut, seperti folder /create.
      = /create/page.jsx nya itu nanti dijadikan children si layout.jsx (liat aja kode si laoyut.jsx)
      = kenapa bisa gitu? memang itu lah cara kerja routingnya next

        = Jadi si create itu tetap bisa diarahin ke /create, tetapi dibungkus oleh layout.jsx

5. const handleHandleAn = (e) => {
    // Mengakses properti target dari objek event
    console.log('Element yang memicu event:', e.target);   'uhuy'
    // Lakukan sesuatu dengan elemen yang memicu event
  };

  return (
    <div>
      {/* Memasang event handler pada elemen JSX */}
      <button onClick={handleHandleAn}>Klik Saya</button>
    </div>
  );

Outpunya dari si 'uhuy' : Element yang memicu event: <button>Klik Saya</button> (outputnya adalah HTML karna pake si target | target itu syntax DOM)

6.  Objek event merepresentasikan kejadian atau interaksi tertentu yang terjadi pada elemen HTML.
  Analogi : 
    - Jika ada yang meniup lilin, maka object event / e ini adalah catatan yang mencatat apa saja yang terjadi saaat meniup lilin. 
    seperti :
      + siapa yang meniup lilin (e.target), 
      + apa jenis lilin yang ditiup (e.type),
      + yang jenis e lainnya aku ndak tau dan ga peduli karna belum kepake

7. Jenis-jenis e (object event) : 
- e.target: Mengacu pada elemen HTML yang memicu event.
- e.type: Menyatakan jenis event yang terjadi, seperti 'click', 'change', dll.
- e.preventDefault(): Metode untuk mencegah perilaku default dari event tersebut, seperti mengirimkan formulir pada event 'submit'.
- e.stopPropagation(): Metode untuk menghentikan penyebaran event ke elemen lain dalam hierarki DOM.
- e.key: Menyatakan tombol keyboard yang ditekan pada event 'keypress' atau 'keydown'.
- e.clientX dan e.clientY: Koordinat x dan y dari pointer mouse pada event 'mousemove' atau 'click'.\

8.  const handleChange = (e) => {
      const { name, value } = e.target;
      setFormData((prevData) => ({
        ...prevData,
        [name]: value,
      }));
    }

    Penjelasan : 
      + apapun yang informasi yang berada saat handleChange terjadi akan dicatat di e.
      + aku mau si jenis catatan e nya adalah jenis catatan e.target yang di mana e.targetnya adalah atribut dari tag html berupa name dan value. jadinya e.target.name & e.target.value (menggunakan destrcutive pantek)
      + ini adalah isi dari 
        const [formData, setFormData] = useState({
          username: "",
          password: "",
        });
      + aku mau mengubah data yang ada di useState dengan si prevData 
        ++ dalam useState, kita menggunakan setFormData(uhuy) uhuy untuk mengubah data yang sebelumnya pada useState tersebut. si uhuy menyalin data yang sebelumnya ada pada useState FormData, lalu akan digantikan dengan data baru yaitu uhuy yang baru. si uhuy di sini analogi dari prevData
      + Karena si useState FormData ini berbentuk object, dan memiliki 2 properti. Maka, itu harus terdefinisi yang mau diubah itu properti yang mana?
      + Lalu kita tidak bisa mengambil properti itu secara langsung jika kita tidak kasih tau komputer
      + Makanya kita kasih seperator pantek untuk mendapatkan semua properti dalam object tersebut. ...prevData
      + lalu kita pakai si computed prop yang ini : [name]. itu gunanya mengambil nilai dari si e.target.name. Karna tapi sbenarnya bentuk dari destructive pantek itu adalah : 
        const name = e.target.name
      + karna kita set di <button name = username/>. Maka si [name] itu sekarang adaalah username
      + si value itu sekarang jadi e.target.value
      + Ketika onChange (saat ada perubahan) kita mau set si username : {formData.username}
      + [name] merupakan e.target.name, ini adalah tumbal agar kita tau, dari properti useState FormData mana yang mau diubah. 
      + Dan [e.target.name] itu akan sama dengan e.target.value

    - Alur : 
      + ketik A
      + masuk ke onChange
      + A akan masuk ke e.target.value, yang di mana e.target.value adalah/ditempati oleh variabel {formData.username}, dengan kata lain sekarang const formData.username = "A"
      + barulah si atribut value yang beradaa di <input value = {formData.username} itu terupdate.
===============================================================================================================

LEAD BY : Irfan Mustafa 

1. Cek d F12. :
  + Network > Header = untuk ngecek Status nya apa 
  + Application = untuk ngeliat cookiesnya udah kesimpen atau engga

===============================================================================================================





  //---------

  const [Username, setUsername] = useState("");
  const [Password, setPassword] = useState("");

  const handleInput = (e) => {
    if (e) {
      if (e.target.id === "username") {
        setUsername(e.target.value);
      }
      if (e.target.id === "password") {
        setPassword(e.target.value);
      }
    }
  };
  //untuk nangkap apa yang diimput di input formm. disimpen di useState nya, bukan di set mek!

  const router = useRouter();

  const {
    mutate: dataLogin, //mutate : data yang dimintain tuh apa?
    status,
    isSuccess,
    isError,
    error,
  } = useLoginUser(); //ctrl+klik kiri aja
  //bawaan library trans-stack
  //const ini dibuat untuk ke useLoginUser, keperluan custom hook useLoginUser()

  const loginUser = () => {
    // if (!Username || !Password) {
    //   alert("Mohon Lengkapi Data !!");
    //   return;
    // }
    dataLogin({
      username: Username,
      password: Password, 
    });
  };//untuk function onClicknya
    //username : Username (req.body dari postman || dari useState)

  useEffect(() => {
    if (isError) {
      console.log(error);
    }
    if (isSuccess) {
      console.log("Login Berhasil");
      router.push("/dashboard");
    }
  }, [status]);
  //handling kalau udah succes atau error pencet button
  // status adalah bawaan trans-stack


  console.log(Username, Password);


  //---------